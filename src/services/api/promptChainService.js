import promptChainsData from "@/services/mockData/promptChains.json";
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

let data = [...promptChainsData.promptChains];

export const promptChainService = {
  async getAll() {
    await delay(300);
    return [...data];
  },

  async getById(id) {
    await delay(250);
    const chain = data.find(item => item.Id === parseInt(id, 10));
    if (!chain) {
      throw new Error('Prompt chain not found');
    }
    return { ...chain };
  },

  async create(chainData) {
    await delay(400);
    const maxId = Math.max(...data.map(item => item.Id), 0);
    const newChain = {
      ...chainData,
      Id: maxId + 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    data.push(newChain);
    return { ...newChain };
  },

  async update(id, updates) {
    await delay(350);
    const index = data.findIndex(item => item.Id === parseInt(id, 10));
    if (index === -1) {
      throw new Error('Prompt chain not found');
    }
    
    const updatedChain = {
      ...data[index],
      ...updates,
      Id: data[index].Id, // Preserve ID
      updatedAt: new Date().toISOString()
    };
    
    data[index] = updatedChain;
    return { ...updatedChain };
  },

  async delete(id) {
    await delay(300);
    const index = data.findIndex(item => item.Id === parseInt(id, 10));
    if (index === -1) {
      throw new Error('Prompt chain not found');
    }
    
    const deletedChain = data[index];
    data.splice(index, 1);
    return { ...deletedChain };
  },

  async generateForm(chainId) {
    await delay(800); // Simulate AI processing
    const chain = await this.getById(chainId);
    
    // Simulate AI-generated form fields based on prompt chain
    const formFields = chain.nodes.map(node => ({
      id: node.id,
      label: node.label,
      variable: node.variable,
      type: node.fieldType,
      required: true,
      options: node.options || null
    }));

    return { fields: formFields, finalPrompt: chain.finalPrompt };
  },

  async executeChain(chainId, responses, apiKey, model) {
    await delay(1200); // Simulate API call
    
    const chain = await this.getById(chainId);
    let finalPrompt = chain.finalPrompt || "Generate content based on the following inputs:";
    
    // Replace variables in final prompt
    Object.entries(responses).forEach(([variable, value]) => {
      finalPrompt = finalPrompt.replace(new RegExp(`{{${variable}}}`, 'g'), value);
    });

    // Simulate AI response
    const mockResponse = `Based on your inputs, here's a generated response that incorporates ${Object.keys(responses).join(', ')}. This would normally be generated by ${model} using your OpenRouter API key.

Generated content with personalized elements based on your specific requirements and preferences.`;

    return {
      prompt: finalPrompt,
      response: mockResponse,
      model: model,
      tokenUsage: { prompt: 150, completion: 320, total: 470 }
    };
  },
  async analyzePrompt(prompt) {
    await delay(1000); // Simulate AI analysis
    
    // AI would analyze the prompt and suggest form fields
    // This is a mock implementation that detects common patterns
    const fields = [];
    let fieldId = 1;
    
    // Detect common field patterns in prompts
    const patterns = [
      { regex: /name|title|product/i, type: 'text', label: 'Name/Title' },
      { regex: /email|contact/i, type: 'email', label: 'Email Address' },
      { regex: /description|details|explain/i, type: 'textarea', label: 'Description' },
      { regex: /category|type|style/i, type: 'select', label: 'Category', options: ['Option 1', 'Option 2', 'Option 3'] },
      { regex: /audience|target|demographic/i, type: 'select', label: 'Target Audience', options: ['General', 'Professional', 'Students', 'Seniors'] },
      { regex: /tone|voice|style/i, type: 'select', label: 'Tone', options: ['Professional', 'Casual', 'Friendly', 'Formal'] },
      { regex: /budget|price|cost/i, type: 'number', label: 'Budget' },
      { regex: /website|url|link/i, type: 'url', label: 'Website URL' }
    ];

    patterns.forEach(pattern => {
      if (pattern.regex.test(prompt)) {
        fields.push({
          id: `field-${fieldId++}`,
          label: pattern.label,
          variable: pattern.label.toLowerCase().replace(/[^a-z0-9]/g, '_'),
          type: pattern.type,
          options: pattern.options || null,
          required: true
        });
      }
    });

    // Always add at least one field if none detected
    if (fields.length === 0) {
      fields.push({
        id: 'field-1',
        label: 'User Input',
        variable: 'user_input',
        type: 'text',
required: true
      });
    }

    return { fields, analyzedPrompt: prompt };
  }
};

export default promptChainService;